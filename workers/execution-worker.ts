// Execution worker - Processes approved completions and creates PRs
import { config } from 'dotenv';
import { resolve } from 'path';
config({ path: resolve(__dirname, '../.env.local') });

import { Worker, Job } from 'bullmq';
import Redis from 'ioredis';
import { PrismaClient } from '@prisma/client';
import { cloneRepo, createBranch, applyChanges, commitChanges, pushBranch, cleanup } from '../lib/git';
import { createPullRequest, parseRepoUrl } from '../lib/github';
import { sendSlackNotification } from '../lib/slack';

// Create fresh Prisma client with direct connection (not pooler)
const directDatabaseUrl = process.env.DATABASE_URL?.replace(':6543', ':5432').replace('?pgbouncer=true&connection_limit=1', '');
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: directDatabaseUrl,
    },
  },
});

// Redis connection for BullMQ worker
const connection = new Redis(
  process.env.REDIS_URL || 'redis://localhost:6379',
  {
    maxRetriesPerRequest: null,
    enableReadyCheck: false,
    // TLS for Upstash (rediss://)
    tls: process.env.REDIS_URL?.startsWith('rediss://') ? {} : undefined,
  }
);

interface ExecutionJob {
  completionId: string;
}

/**
 * Execute a completion: clone repo → create branch → commit → push → create PR
 */
async function executeCompletion(completionId: string): Promise<void> {
  console.log(`[Execution Worker] Processing completion: ${completionId}`);

  try {
    // Fetch completion with project details
    const completion = await prisma.completion.findUnique({
      where: { id: completionId },
      include: { project: true },
    });

    if (!completion) {
      console.error(`[Execution Worker] Completion ${completionId} not found`);
      return;
    }

    // Check policy
    if (completion.policy === 'suggest_only') {
      console.log(`[Execution Worker] Completion ${completionId} is suggest_only - skipping execution`);
      await prisma.completion.update({
        where: { id: completionId },
        data: { status: 'completed' },
      });
      return;
    }

    // Check approval for approval_required policy
    if (completion.policy === 'approval_required' && !completion.userApproved) {
      console.log(`[Execution Worker] Completion ${completionId} requires approval - skipping`);
      return;
    }

    // Mark as in progress
    await prisma.completion.update({
      where: { id: completionId },
      data: { status: 'in_progress' },
    });

    console.log(`[Execution Worker] Completion ${completionId} marked as in_progress`);

    // Execute Git + GitHub workflow
    let repoPath: string | null = null;

    try {
      // Step 1: Clone repository with authentication
      const repo = completion.project.repo;
      if (!repo) {
        throw new Error('Project has no repository configured');
      }

      // Get authenticated clone URL using GitHub App token
      const { getAuthenticatedCloneUrl } = await import('../lib/github');
      const authenticatedUrl = await getAuthenticatedCloneUrl(repo);

      // Preserve original repo URL for PR creation
      const repoUrl = repo.startsWith('http')
        ? repo
        : `https://github.com/${repo}.git`;

      console.log(`[Execution Worker] Cloning repository: ${repoUrl}`);
      repoPath = await cloneRepo(authenticatedUrl);

      // Step 2: Create branch
      const branchName = `ai-improvement-${completionId.slice(0, 8)}`;
      await createBranch(repoPath, branchName);

      // Step 3: Apply changes (placeholder for now)
      // TODO: Parse completion.diff and apply actual changes in future story
      const placeholderChanges = [
        {
          path: 'AI_IMPROVEMENTS.md',
          content: `# AI-Generated Improvements\n\nCompletion ID: ${completionId}\nGenerated: ${new Date().toISOString()}\n\n${completion.title}\n\n## Details\n${completion.rationale}\n`,
        },
      ];

      await applyChanges(repoPath, placeholderChanges);

      // Step 4: Commit changes
      const commitMessage = `AI improvement: ${completion.title}`;
      await commitChanges(repoPath, commitMessage);

      // Step 5: Push branch
      await pushBranch(repoPath, branchName);

      // Step 6: Create pull request
      const { owner, repo: repoName } = parseRepoUrl(repoUrl);
      const prUrl = await createPullRequest({
        owner,
        repo: repoName,
        head: branchName,
        base: 'main', // TODO: Make configurable per project
        title: completion.title,
        body: `**Generated by AI Co-Founder**\n\nCompletion ID: ${completionId}\nPriority: ${completion.priority}\n\n${completion.rationale}`,
      });

      console.log(`[Execution Worker] PR created: ${prUrl.url}`);

      // Step 7: Update completion with PR URL
      await prisma.completion.update({
        where: { id: completionId },
        data: {
          status: 'completed',
          executedAt: new Date(),
          prUrl: prUrl.url,
        },
      });

      console.log(`[Execution Worker] Completion ${completionId} executed successfully`);

      // Step 8: Send Slack notification
      try {
        await sendSlackNotification({
          completionId,
          projectName: completion.project.name,
          title: completion.title,
          rationale: completion.rationale,
          prUrl: prUrl.url,
        });
      } catch (slackError) {
        // Don't fail the completion if Slack notification fails
        console.error(`[Execution Worker] Failed to send Slack notification:`, slackError);
      }
    } finally {
      // Cleanup cloned repository
      if (repoPath) {
        await cleanup(repoPath);
      }
    }
  } catch (error) {
    console.error(`[Execution Worker] Error executing completion ${completionId}:`, error);

    // Mark as failed
    await prisma.completion.update({
      where: { id: completionId },
      data: { status: 'failed' },
    });
  }
}

/**
 * Worker processor
 */
async function processExecutionJob(job: Job<ExecutionJob>): Promise<void> {
  const { completionId } = job.data;
  await executeCompletion(completionId);
}

/**
 * Start the worker
 */
const worker = new Worker<ExecutionJob>('execution-queue', processExecutionJob, {
  connection,
  concurrency: 3, // Process 3 completions concurrently
  limiter: {
    max: 10, // Max 10 jobs per duration
    duration: 60000, // 1 minute
  },
});

worker.on('completed', (job) => {
  console.log(`[Execution Worker] Job ${job.id} completed`);
});

worker.on('failed', (job, err) => {
  console.error(`[Execution Worker] Job ${job?.id} failed:`, err);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('[Execution Worker] Shutting down...');
  await worker.close();
  await connection.quit();
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('[Execution Worker] Shutting down...');
  await worker.close();
  await connection.quit();
  await prisma.$disconnect();
  process.exit(0);
});

console.log('[Execution Worker] Worker started');

export { executeCompletion };
