// Orchestrator worker - Processes individual project analyses
import { config } from 'dotenv';
import { resolve } from 'path';
config({ path: resolve(__dirname, '../.env.local') });

import { Worker, Job } from 'bullmq';
import Redis from 'ioredis';
import { PrismaClient } from '@prisma/client';
import { runOrchestrator, type ScanContext } from '../lib/orchestrator';
import { sendCompletionNotification } from '../lib/slack';
import { createLinearTask, getDefaultTeamId, mapPriorityToLinear, addLinearComment } from '../lib/linear';

// Create fresh Prisma client with direct connection (not pooler)
const directDatabaseUrl = process.env.DATABASE_URL?.replace(':6543', ':5432').replace('?pgbouncer=true&connection_limit=1', '');
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: directDatabaseUrl,
    },
  },
});

// Redis connection for BullMQ worker
const connection = new Redis(
  process.env.REDIS_URL || 'redis://localhost:6379',
  {
    maxRetriesPerRequest: null,
    enableReadyCheck: false,
    // TLS for Upstash (rediss://)
    tls: process.env.REDIS_URL?.startsWith('rediss://') ? {} : undefined,
  }
);

interface OrchestratorJob {
  projectId: string;
  scanContext: ScanContext;
  runId: string;
  workspaceId: string;
}

/**
 * Process a single project analysis
 */
async function processProject(job: Job<OrchestratorJob>): Promise<void> {
  const { projectId, scanContext, runId, workspaceId } = job.data;

  console.log(`[Orchestrator Worker] Processing project ${projectId} for run ${runId}`);

  try {
    // Run orchestrator for this single project
    const result = await runOrchestrator([scanContext]);

    console.log(`[Orchestrator Worker] Project ${projectId}: ${result.findings.length} findings, ${result.completions.length} completions`);

    // Save agent findings to database
    for (const finding of result.findings) {
      await prisma.agentFinding.create({
        data: {
          workspaceId,
          runId,
          projectId: finding.projectId,
          agent: finding.agent,
          issue: finding.issue,
          action: finding.action,
          severity: finding.severity,
          effort: finding.effort,
          impact: finding.impact,
          confidence: finding.confidence,
          rank: finding.rank || 0,
        },
      });
    }

    // Get project for notifications
    const project = await prisma.project.findUnique({
      where: { id: projectId },
    });

    // Save completions to database, create Linear tasks, and send Slack notifications
    for (const completion of result.completions) {
      const dbCompletion = await prisma.completion.create({
        data: {
          workspaceId,
          runId,
          projectId: completion.projectId,
          title: completion.title,
          rationale: completion.rationale,
          priority: completion.priority,
          policy: completion.policy,
          status: 'pending',
        },
      });

      // Create Linear task
      try {
        const teamId = await getDefaultTeamId();
        const linearPriority = mapPriorityToLinear(completion.priority);

        const linearTask = await createLinearTask({
          teamId,
          title: completion.title,
          description: `**Project:** ${project?.name || 'Unknown'}\n\n**Rationale:**\n${completion.rationale}\n\n**Priority:** ${completion.priority}\n**Policy:** ${completion.policy}\n\n**Run ID:** ${runId}`,
          priority: linearPriority,
        });

        // Update completion with Linear task ID
        await prisma.completion.update({
          where: { id: dbCompletion.id },
          data: { linearTaskId: linearTask.id },
        });

        console.log(`[Orchestrator Worker] Created Linear task ${linearTask.identifier} for completion ${dbCompletion.id}`);

        // Post agent dialogue as a comment
        if (result.conversation && result.conversation.length > 0) {
          const dialogue = result.conversation
            .slice(0, 10) // Limit to first 10 messages to avoid overly long comments
            .map((msg, i) => `${i + 1}. ${msg}`)
            .join('\n\n');

          await addLinearComment(
            linearTask.id,
            `**Agent Dialogue:**\n\n${dialogue}\n\n_Generated by AI Co-Founder orchestrator run ${runId}_`
          );

          console.log(`[Orchestrator Worker] Posted agent dialogue to Linear task ${linearTask.identifier}`);
        }
      } catch (linearError) {
        // Log but don't fail the job if Linear fails
        console.error('[Orchestrator Worker] Linear task creation failed:', linearError);
      }

      // Send Slack notification (non-blocking)
      if (project) {
        try {
          await sendCompletionNotification({
            completionId: dbCompletion.id,
            projectName: project.name,
            title: completion.title,
            rationale: completion.rationale,
            priority: completion.priority,
            policy: completion.policy,
          });
        } catch (slackError) {
          // Log but don't fail the job if Slack fails
          console.error('[Orchestrator Worker] Slack notification failed:', slackError);
        }
      }
    }

    console.log(`[Orchestrator Worker] Project ${projectId} complete: ${result.findings.length} findings, ${result.completions.length} completions saved`);

  } catch (error) {
    console.error(`[Orchestrator Worker] Error processing project ${projectId}:`, error);
    throw error; // Let BullMQ handle retries
  }
}

// Create the worker
const worker = new Worker('orchestrator', processProject, {
  connection,
  concurrency: 1, // Process one project at a time
  limiter: {
    max: 1, // Max 1 job
    duration: 60000, // per 60 seconds (avoid rate limits)
  },
});

// Event handlers
worker.on('completed', (job) => {
  console.log(`[Orchestrator Worker] Job ${job.id} completed successfully`);
});

worker.on('failed', (job, err) => {
  console.error(`[Orchestrator Worker] Job ${job?.id} failed:`, err);
});

worker.on('error', (err) => {
  console.error('[Orchestrator Worker] Worker error:', err);
});

console.log('[Orchestrator Worker] Started and waiting for jobs...');

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('[Orchestrator Worker] Shutting down...');
  await worker.close();
  await connection.quit();
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('[Orchestrator Worker] Shutting down...');
  await worker.close();
  await connection.quit();
  await prisma.$disconnect();
  process.exit(0);
});
