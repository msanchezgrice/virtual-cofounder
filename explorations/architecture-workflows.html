<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Virtual Cofounder Workflow Diagrams</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        background: #f8fafc;
        color: #0f172a;
        margin: 0;
        padding: 32px 20px 60px;
      }
      main {
        max-width: 980px;
        margin: 0 auto;
      }
      h1 {
        font-size: 28px;
        margin: 0 0 8px;
      }
      p {
        color: #475569;
        margin: 0 0 24px;
      }
      section {
        background: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 18px;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.04);
      }
      .before-after {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 16px;
        margin-bottom: 18px;
      }
      .before-after section {
        margin-bottom: 0;
      }
      h2 {
        font-size: 18px;
        margin: 0 0 12px;
      }
      .note {
        font-size: 13px;
        color: #64748b;
        margin-top: 12px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  </head>
  <body>
    <main>
      <h1>Virtual Cofounder Workflow Diagrams</h1>
      <p>Local visualization of scans, orchestrator runs, agents, Slack, and execution flows.</p>

      <section>
        <h2>1) System Overview</h2>
        <pre class="mermaid">
graph LR
  UI[Next.js UI] --> API[Next.js API routes]
  API --> DB[(Supabase Postgres)]
  API --> Redis[(Upstash Redis / BullMQ)]
  API --> Slack[Slack API]
  API --> Linear[Linear API]
  API --> Anthropic[Anthropic API]
  Redis --> ScanWorker[Railway scan-worker.ts]
  Redis --> ExecWorker[Railway execution-worker.ts]
        </pre>
      </section>

      <div class="before-after">
        <section>
          <h2>Change View (Before)</h2>
          <pre class="mermaid">
graph TD
  SlackCheckin["Slack check-in (scheduled)"] --> Priorities["user_priorities (check-in only)"]
  Scans["scans (daily)"] --> Orchestrator["/api/orchestrator/run (manual/cron)"]
  Priorities -.-> Orchestrator
  Orchestrator --> Completions["completions (ranked by findings)"]
  Approve["Slack approve button"] --> SlackEvents["/api/slack/events"]
  SlackEvents --> Status["completion.status = in_progress"]
  Status -.-> Script["queue-completion-to-production script"]
  Script --> ExecQueue["execution-queue"]
  ExecQueue --> Worker["execution-worker.ts (when running)"]
          </pre>
          <div class="note">
            Before: only check-in messages become priorities; approvals do not auto-queue execution.
          </div>
        </section>

        <section>
          <h2>Change View (After)</h2>
          <pre class="mermaid">
graph TD
  SlackAll["Slack inbound (DMs, channels, mentions)"] --> SlackEvents["/api/slack/events"]
  LinearComments["Linear comments"] --> LinearWebhook["/api/linear/webhook"]
  SlackEvents --> Inbounds["slack_inbounds"]
  Inbounds --> Signals["priority_signals (P0-P3 + factors)"]
  LinearWebhook --> Signals
  Signals --> Rerank["rerank trigger (user: immediate, others: 2x/day)"]
  Scans["scans (daily)"] --> Orchestrator["/api/orchestrator/run"]
  Signals --> Orchestrator
  Orchestrator --> StackRank["stack-ranked work per project"]
  StackRank --> Completions["completions (score + rank + priority)"]
  Completions --> Queue["execution-queue (priority)"]
  Approve["Slack approve button"] --> Queue
  Queue --> Worker["execution-worker.ts (always on)"]
          </pre>
          <div class="note">
            After: all inbound signals affect rank; approvals enqueue work immediately.
          </div>
        </section>
      </div>

      <section>
        <h2>2) Priority Intake (Slack Check-in)</h2>
        <pre class="mermaid">
graph TD
  Cron9[Vercel Cron 9:00] --> Checkin[/api/slack/check-in/]
  Checkin --> SlackMsg[Slack message]
  SlackMsg -->|user reply| Events[/api/slack/events/]
  Events --> Parser[priority-parser]
  Parser --> Priorities[(user_priorities)]
  Priorities -.->|planned weighting input| Orchestrator[/api/orchestrator/run/]
        </pre>
      </section>

      <section>
        <h2>3) Scanning Pipeline</h2>
        <pre class="mermaid">
graph TD
  Cron905["Vercel Cron 9:05"] --> Trigger["/api/scans/trigger"]
  Trigger --> Queue["BullMQ scans queue"]
  Queue --> Worker["scan-worker.ts"]
  Worker --> Domain["scanDomain"]
  Worker --> SEO["scanSEO"]
  Worker --> Analytics["scanAnalytics"]
  Domain --> Scans["scans (table)"]
  SEO --> Scans
  Analytics --> Scans
  Scans --> ScansAPI["/api/scans"]
  ScansAPI --> Dashboard["/dashboard"]
        </pre>
      </section>

      <section>
        <h2>4) Orchestrator Run + Outputs</h2>
        <pre class="mermaid">
graph TD
  RunAPI[/api/orchestrator/run/] --> FetchScans[fetch scans last 24h]
  FetchScans --> Context[ScanContext builder]
  Context --> Orchestrator[lib/orchestrator.ts]
  Orchestrator --> Agents[Agents + Anthropic]
  Agents --> Findings[(agent_findings)]
  Orchestrator --> Rank[rankFindings]
  Rank --> Completions[(completions)]
  Orchestrator --> RunRow[(orchestrator_runs)]
  Completions --> SlackNotify[Slack completion notifications]
  Completions --> LinearTasks[Linear tasks + comments]
        </pre>
      </section>

      <section>
        <h2>5) Run Data Lineage</h2>
        <pre class="mermaid">
graph LR
  RunId[runId] --> OrchestratorRuns[(orchestrator_runs)]
  RunId --> Findings[(agent_findings)]
  RunId --> Completions[(completions)]
  Findings -.-> Completions
        </pre>
      </section>

      <section>
        <h2>6) Execution Worker Pipeline</h2>
        <pre class="mermaid">
graph TD
  Approve[Slack Approve button] --> Events[/api/slack/events/]
  Events --> UpdateStatus[completion status = in_progress]
  UpdateStatus -.->|queue via script| Queue[(execution-queue)]
  Queue --> Worker[execution-worker.ts]
  Worker --> Git[clone/branch/commit/push]
  Git --> PR[GitHub PR]
  PR --> UpdateCompletion[completion.status=completed + prUrl]
  UpdateCompletion --> SlackDone[Slack notification]
  UpdateCompletion --> LinearUpdate[Linear status + comments]
        </pre>
      </section>

      <section>
        <h2>7) UI Data Surfaces</h2>
        <pre class="mermaid">
graph TD
  Dashboard["/dashboard (scan overview)"] --> ScansAPI["/api/scans"]
  Agents["/agents (activity view)"] --> AgentsAPI["/api/agents"]
  Completions["/completions (work queue)"] --> CompletionsAPI["/api/completions"]
  Project["/projects/:id (detail)"] --> ProjectAPI["/api/projects/:id"]
  AgentsAPI --> CompletionsTable["completions (table)"]
  ProjectAPI --> CompletionsTable
  ProjectAPI -.->|legacy scan fields| ProjectTable["projects (table)"]
        </pre>
        <div class="note">
          Notes: Agents UI derives activity from completions text, not agent_findings. Project detail API reads legacy scan fields; canonical scan data is in scans.
        </div>
      </section>

      <section>
        <h2>8) User-Facing UX Flow (Your Perspective)</h2>
        <pre class="mermaid">
graph TD
  You["You"] --> Checkin["Slack check-in (set priorities)"]
  Checkin --> Priorities["Priorities saved (72h)"]
  DailyScans["Projects scanned daily"] --> Orchestrator["Orchestrator + agents analyze"]
  Priorities --> Orchestrator
  Orchestrator --> Ranked["Ranked work (completions)"]
  Ranked --> Slack["Slack: approvals + updates"]
  Ranked --> Dashboard["Dashboard: scans + work queue"]
  Ranked --> Linear["Linear: tasks + status"]
  Slack --> You
  Dashboard --> You
  Linear --> You
        </pre>
      </section>
    </main>

    <script>
      mermaid.initialize({
        startOnLoad: true,
        theme: "default",
        securityLevel: "loose"
      });
    </script>
  </body>
</html>
